// @ts-nocheck
/**
 * Create GitHub Issue Endpoint
 * Auto-generates GitHub issues from AI feedback with duplicate prevention
 */

const { createLogger, createLoggerFromEvent, createTimer } = require('./utils/logger.cjs');
const { getCollection } = require('./utils/mongodb.cjs');
const { getCorsHeaders } = require('./utils/cors.cjs');
const { retryAsync } = require('./utils/retry.cjs');
const { searchGitHubIssues } = require('./utils/github-api.cjs');
const {
  createStandardEntryMeta,
  logDebugRequestSummary
} = require('./utils/handler-logging.cjs');

/**
 * Emoji pattern used throughout for normalization
 */
const EMOJI_PATTERN = /[\u{1F534}\u{1F7E0}\u{1F7E1}\u{26AA}\u{1F324}\u{1F5C4}\u{1F3A8}\u{26A1}\u{1F50C}\u{1F4CA}]\uFE0F?/gu;

/**
 * Search for similar issues before creating a new one
 * @param {string} title - Issue title to search for
 * @param {object} log - Logger instance
 * @returns {Promise<object>} Similar issues found
 */
async function findSimilarIssues(title, log) {
  log.info('Searching for similar issues', { title });

  try {
    // Extract key terms from the title for better search
    const searchQuery = title
      .replace(EMOJI_PATTERN, '') // Remove emojis
      .trim();

    // Search both open and closed issues
    const results = await searchGitHubIssues({
      query: searchQuery,
      state: 'all',
      per_page: 10
    }, log);

    if (results.error) {
      log.warn('Failed to search for similar issues, will proceed with creation', {
        error: results.message
      });
      return { items: [], searchFailed: true };
    }

    log.info('Similar issues search completed', {
      totalFound: results.total_count,
      returnedCount: results.items?.length || 0
    });

    return results;
  } catch (error) {
    log.error('Error searching for similar issues', {
      error: error.message,
      title
    });
    // Don't block issue creation if search fails
    return { items: [], searchFailed: true, errorMessage: error.message };
  }
}

/**
 * Check if an issue is an exact duplicate (same title, close match)
 * @param {string} newTitle - Title of the new issue
 * @param {array} existingIssues - List of existing issues
 * @returns {object} Duplicate check result
 */
function checkForExactDuplicate(newTitle, existingIssues) {
  if (!existingIssues || existingIssues.length === 0) {
    return { isDuplicate: false };
  }

  // Normalize titles for comparison (remove emojis, lowercase, trim)
  const normalizedNewTitle = newTitle
    .replace(EMOJI_PATTERN, '')
    .toLowerCase()
    .trim();

  for (const issue of existingIssues) {
    const normalizedExistingTitle = issue.title
      .replace(EMOJI_PATTERN, '')
      .toLowerCase()
      .trim();

    // Check for exact match or very close match (>90% similarity)
    if (normalizedExistingTitle === normalizedNewTitle) {
      return {
        isDuplicate: true,
        duplicateIssue: issue,
        reason: 'Exact title match'
      };
    }

    // Skip comparison if either title is empty after normalization
    if (!normalizedNewTitle || !normalizedExistingTitle) {
      continue;
    }

    // Check for high similarity (simple word-based comparison)
    const newWords = new Set(normalizedNewTitle.split(/\s+/));
    const existingWords = new Set(normalizedExistingTitle.split(/\s+/));
    const commonWords = [...newWords].filter(word => existingWords.has(word));
    // Use union size for balanced similarity (Jaccard index)
    const unionSize = newWords.size + existingWords.size - commonWords.length;

    // Skip if there are no words to compare (prevents division by zero)
    if (unionSize === 0) {
      continue;
    }

    const similarity = commonWords.length / unionSize;

    if (similarity > 0.9 && issue.state === 'open') {
      return {
        isDuplicate: true,
        duplicateIssue: issue,
        reason: `${Math.round(similarity * 100)}% title similarity with open issue`
      };
    }
  }

  return { isDuplicate: false };
}

/**
 * Format feedback as GitHub issue
 * @param {object} feedback - Feedback data
 * @param {object} [similarIssues] - Similar issues found during search
 */
function formatGitHubIssue(feedback, similarIssues = null) {
  const priorityEmoji = {
    critical: 'ðŸ”´',
    high: 'ðŸŸ ',
    medium: 'ðŸŸ¡',
    low: 'âšª'
  };

  const categoryEmoji = {
    weather_api: 'ðŸŒ¤ï¸',
    data_structure: 'ðŸ—„ï¸',
    ui_ux: 'ðŸŽ¨',
    performance: 'âš¡',
    integration: 'ðŸ”Œ',
    analytics: 'ðŸ“Š'
  };

  const title = `${priorityEmoji[feedback.priority]} ${categoryEmoji[feedback.category]} ${feedback.suggestion.title}`;

  const body = `
## AI-Generated Feedback

**Type:** ${feedback.feedbackType.replace('_', ' ')}  
**Category:** ${feedback.category.replace('_', ' ')}  
**Priority:** ${feedback.priority.toUpperCase()}  
**Generated by:** ${feedback.geminiModel}  
**System ID:** ${feedback.systemId}

---

### Description

${feedback.suggestion.description}

### Rationale

${feedback.suggestion.rationale}

### Expected Benefit

${feedback.suggestion.expectedBenefit}

### Implementation Details

${feedback.suggestion.implementation}

**Estimated Effort:** ${feedback.suggestion.estimatedEffort}

${feedback.suggestion.affectedComponents && feedback.suggestion.affectedComponents.length > 0 ? `
### Affected Components

${feedback.suggestion.affectedComponents.map(comp => `- ${comp}`).join('\n')}
` : ''}

${feedback.suggestion.codeSnippets && feedback.suggestion.codeSnippets.length > 0 ? `
### Suggested Code

\`\`\`javascript
${feedback.suggestion.codeSnippets.join('\n\n')}
\`\`\`
` : ''}

${similarIssues && similarIssues.items && similarIssues.items.length > 0 ? `
---

### Related Issues

The AI identified these potentially related issues:

${similarIssues.items.slice(0, 5).map(issue =>
    `- ${issue.state === 'open' ? 'ðŸŸ¢' : 'ðŸ”´'} #${issue.number}: [${issue.title}](${issue.html_url})`
  ).join('\n')}

${similarIssues.items.length > 5 ? `\n*...and ${similarIssues.items.length - 5} more*` : ''}
` : ''}

---

*This issue was automatically generated from AI feedback on ${new Date(feedback.timestamp).toLocaleDateString()}*  
*Feedback ID: ${feedback.id}*
${similarIssues && similarIssues.searchFailed ? '\n*Note: Similar issues search was not performed due to an error.*' : ''}
`;

  const labels = [
    'ai-generated',
    `priority-${feedback.priority}`,
    `category-${feedback.category}`,
    feedback.feedbackType
  ];

  return { title, body, labels };
}

/**
 * Create GitHub issue using the GitHub API
 * @param {object} issueData - The issue data with title, body, and labels
 * @param {object} log - Logger instance for structured logging
 */
async function createGitHubIssueAPI(issueData, log) {
  // Validate required fields
  if (!issueData || typeof issueData !== 'object') {
    throw new Error('issueData must be an object');
  }

  if (!issueData.title || typeof issueData.title !== 'string') {
    throw new Error('issueData.title is required and must be a string');
  }

  if (!issueData.body || typeof issueData.body !== 'string') {
    throw new Error('issueData.body is required and must be a string');
  }

  // Get repository info from environment or use default
  const repoOwner = process.env.GITHUB_REPO_OWNER || 'Treystu';
  const repoName = process.env.GITHUB_REPO_NAME || 'BMSview';
  const githubToken = process.env.GITHUB_TOKEN;

  if (!githubToken) {
    throw new Error('GITHUB_TOKEN environment variable is not configured. Please set it in Netlify environment variables.');
  }

  log.info('Calling GitHub API to create issue', {
    repoOwner,
    repoName,
    title: issueData.title,
    labelsCount: issueData.labels?.length || 0
  });

  // Wrap the fetch call with retry logic for transient failures
  const response = await retryAsync(async () => {
    const res = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/issues`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Accept': 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'User-Agent': 'BMSview-AI-Feedback',
        'X-GitHub-Api-Version': '2022-11-28'
      },
      body: JSON.stringify(issueData)
    });

    // Check for retryable errors (rate limit, server errors)
    if (!res.ok && (res.status === 429 || res.status >= 500)) {
      const error = new Error(`GitHub API error: ${res.status}`);
      error.status = res.status;
      throw error;
    }

    return res;
  }, {
    retries: 3,
    baseDelayMs: 500,
    jitterMs: 200,
    shouldRetry: (e) => {
      // Retry on network errors (TypeError from fetch)
      if (e instanceof TypeError) return true;
      // Retry on rate limit or server errors
      if (e.status === 429 || e.status >= 500) return true;
      return false;
    },
    log
  });

  if (!response.ok) {
    const errorJson = await response.json().catch(() => ({}));

    const errorDetails = {
      status: response.status,
      message: errorJson.message || response.statusText,
      documentation_url: errorJson.documentation_url,
      errors: errorJson.errors
    };

    let errorMessage = `GitHub API error (${response.status}): ${errorDetails.message}`;
    if (errorDetails.documentation_url) {
      errorMessage += `\nSee: ${errorDetails.documentation_url}`;
    }

    const error = new Error(errorMessage);
    error.status = response.status;
    error.details = errorDetails;
    throw error;
  }

  const result = await response.json();

  log.info('GitHub issue created successfully', {
    issueNumber: result.number,
    issueUrl: result.html_url
  });

  return {
    number: result.number,
    url: result.url,
    html_url: result.html_url,
    state: result.state,
    created_at: result.created_at
  };
}

/**
 * Main handler
 * @param {import('./utils/jsdoc-types.cjs').NetlifyEvent} event
 * @param {import('./utils/jsdoc-types.cjs').NetlifyContext} context
 */
exports.handler = async (event, context) => {
  const log = createLoggerFromEvent('create-github-issue', event, context);
  const timer = createTimer(log, 'create-github-issue-handler');
  const headers = getCorsHeaders(event);

  log.entry(createStandardEntryMeta(event));
  logDebugRequestSummary(log, event, {
    label: 'Create GitHub issue request',
    includeBody: true,
    bodyMaxStringLength: 20000
  });

  // Handle preflight
  if (event.httpMethod === 'OPTIONS') {
    log.debug('OPTIONS preflight request');
    timer.end();
    log.exit(200);
    return { statusCode: 200, headers };
  }

  try {
    if (event.httpMethod !== 'POST') {
      log.warn('Method not allowed', { method: event.httpMethod });
      timer.end();
      log.exit(405);
      return {
        statusCode: 405,
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Method not allowed' })
      };
    }

    const body = JSON.parse(event.body);
    const { feedbackId, feedback } = body;

    if (!feedbackId && !feedback) {
      return {
        statusCode: 400,
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Either feedbackId or feedback is required' })
      };
    }

    // Get feedback from database if only ID provided
    let feedbackData = feedback;
    if (feedbackId && !feedback) {
      const feedbackCollection = await getCollection('ai_feedback');
      feedbackData = await feedbackCollection.findOne({ id: feedbackId });

      if (!feedbackData) {
        return {
          statusCode: 404,
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({ error: 'Feedback not found' })
        };
      }

      // Check if already has GitHub issue
      if (feedbackData.githubIssue) {
        return {
          statusCode: 409,
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            error: 'GitHub issue already exists for this feedback',
            githubIssue: feedbackData.githubIssue
          })
        };
      }
    }

    log.info('Creating GitHub issue for AI feedback', {
      feedbackId: feedbackData.id,
      priority: feedbackData.priority
    });

    // Search for similar issues first (duplicate prevention)
    const similarIssues = await findSimilarIssues(
      feedbackData.suggestion?.title || 'AI Feedback',
      log
    );

    // Check for exact duplicates
    const duplicateCheck = checkForExactDuplicate(
      feedbackData.suggestion?.title || 'AI Feedback',
      similarIssues.items
    );

    if (duplicateCheck.isDuplicate) {
      log.warn('Duplicate issue detected', {
        feedbackId: feedbackData.id,
        duplicateIssueNumber: duplicateCheck.duplicateIssue.number,
        reason: duplicateCheck.reason
      });

      // Return conflict status with duplicate information
      return {
        statusCode: 409,
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          error: 'Duplicate issue detected',
          reason: duplicateCheck.reason,
          duplicateIssue: {
            number: duplicateCheck.duplicateIssue.number,
            title: duplicateCheck.duplicateIssue.title,
            url: duplicateCheck.duplicateIssue.html_url,
            state: duplicateCheck.duplicateIssue.state
          },
          suggestion: 'Review the existing issue instead of creating a duplicate. Manual override may be possible through the admin interface.',
          feedbackId: feedbackData.id
        })
      };
    }

    // Log similar issues found (audit trail)
    if (similarIssues.items && similarIssues.items.length > 0) {
      log.info('Similar issues found during duplicate check', {
        feedbackId: feedbackData.id,
        similarCount: similarIssues.items.length,
        similarIssues: similarIssues.items.slice(0, 3).map(i => ({
          number: i.number,
          title: i.title,
          state: i.state
        }))
      });
    }

    // Format issue with similar issues included in body
    const issueData = formatGitHubIssue(feedbackData, similarIssues);

    // Create GitHub issue
    const githubIssue = await createGitHubIssueAPI(issueData, log);

    // Update feedback with GitHub issue info
    if (feedbackId) {
      const feedbackCollection = await getCollection('ai_feedback');
      await feedbackCollection.updateOne(
        { id: feedbackId },
        {
          $set: {
            githubIssue: {
              number: githubIssue.number,
              url: githubIssue.html_url,
              status: githubIssue.state
            },
            updatedAt: new Date()
          }
        }
      );
    }

    log.info('GitHub issue created successfully', {
      feedbackId: feedbackData.id,
      issueNumber: githubIssue.number
    });

    timer.end({ success: true });
    log.exit(200, { issueNumber: githubIssue.number });

    return {
      statusCode: 200,
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        success: true,
        issueNumber: githubIssue.number,
        issueUrl: githubIssue.html_url,
        feedbackId: feedbackData.id,
        similarIssuesFound: similarIssues.items?.length || 0,
        duplicateCheckPerformed: !similarIssues.searchFailed
      })
    };
  } catch (error) {
    log.error('Create GitHub issue error', { error: error.message, stack: error.stack });
    timer.end({ success: false, error: error.message });
    log.exit(500);
    return {
      statusCode: 500,
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: 'Failed to create GitHub issue',
        message: error.message
      })
    };
  }
};

// Export for testing
module.exports.formatGitHubIssue = formatGitHubIssue;
module.exports.createGitHubIssueAPI = createGitHubIssueAPI;
module.exports.findSimilarIssues = findSimilarIssues;
module.exports.checkForExactDuplicate = checkForExactDuplicate;
