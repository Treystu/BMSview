/**
 * @fileoverview Client service module for BMSview application.
 * This module handles all client-side API interactions, data fetching, and caching.
 * It provides a comprehensive interface for managing battery systems, analysis records,
 * and administrative functions.
 * 
 * @module clientService
 */

import type {
    BmsSystem,
    AnalysisData,
    AnalysisRecord,
    WeatherData,
    ServiceResponse,
    BatteryMeasurement
} from '@types/index';

// Type definitions for internal use
interface PaginatedResponse<T> {
    items: T[];
    totalItems: number;
}

// Cache configuration
const CACHE_CONFIG = {
    SHORT: 5_000,    // 5 seconds
    MEDIUM: 10_000,  // 10 seconds
    LONG: 30_000,    // 30 seconds
    MAX: 300_000     // 5 minutes
} as const;

/**
 * In-memory caching system for API responses
 * Uses a Map to store cached data with expiration
 */
class CacheManager {
    private static _cache = new Map<string, { data: any; expires: number }>();
    private static _inFlight = new Map<string, Promise<any>>();

    static get<T>(key: string): T | null {
        const cached = this._cache.get(key);
        return cached && cached.expires > Date.now() ? cached.data : null;
    }

    static set<T>(key: string, data: T, ttl: number): void {
        this._cache.set(key, { data, expires: Date.now() + ttl });
    }

    static getInFlight<T>(key: string): Promise<T> | null {
        return this._inFlight.get(key) as Promise<T> || null;
    }

    static setInFlight<T>(key: string, promise: Promise<T>): void {
        this._inFlight.set(key, promise);
    }

    static deleteInFlight(key: string): void {
        this._inFlight.delete(key);
    }

    static clear(): void {
        this._cache.clear();
        this._inFlight.clear();
    }
}

/**
 * Fetches data from the API with caching support
 * @template T The expected return type
 * @param {string} endpoint The API endpoint to fetch from
 * @param {number} [ttl=5000] Time-to-live for cache in milliseconds
 * @returns {Promise<T>} The fetched data
 */
async function fetchWithCache<T>(endpoint: string, ttl = CACHE_CONFIG.SHORT): Promise<T> {
    const key = endpoint;
    const cached = CacheManager.get<T>(key);
    if (cached) return cached;

    const inFlight = CacheManager.getInFlight<T>(key);
    if (inFlight) return inFlight;

    const promise = (async () => {
        try {
            const data = await apiFetch<T>(endpoint);
            CacheManager.set(key, data, ttl);
            return data;
        } finally {
            CacheManager.deleteInFlight(key);
        }
    })();

    CacheManager.setInFlight(key, promise);
    return promise;
}

/**
 * Generates a unique key for analysis data
 * Used for finding duplicates in already-fetched data
 * @param {AnalysisData} data The analysis data to generate a key for
 * @returns {string} A unique key based on the analysis data
 */
const generateAnalysisKey = (data: AnalysisData): string => {
    if (!data) return Math.random().toString();
    
    const voltage = data.overallVoltage ? 
        (Math.round(data.overallVoltage * 10) / 10).toFixed(1) : 'N/A';
    const current = data.current ? 
        (Math.round(data.current * 10) / 10).toFixed(1) : 'N/A';
    const soc = data.stateOfCharge ? 
        Math.round(data.stateOfCharge) : 'N/A';
    const cellVoltagesKey = data.cellVoltages?.length > 0 ? 
        data.cellVoltages.map(v => (Math.round(v * 1000) / 1000).toFixed(3)).join(',') : 
        'nocells';
    
    return `${data.dlNumber || 'none'}|${voltage}|${current}|${soc}|${cellVoltagesKey}`;
};

/**
 * Structured logging function for client-side operations
 * @param {'info' | 'warn' | 'error'} level Log level
 * @param {string} message Log message
 * @param {object} context Additional context data
 */
const log = (level: 'info' | 'warn' | 'error', message: string, context: object = {}) => {
    console.log(JSON.stringify({
        level: level.toUpperCase(),
        timestamp: new Date().toISOString(),
        service: 'clientService',
        message,
        context
    }));
};

/**
 * Generic API fetch helper with error handling and auth token support
 * @template T Expected response type
 * @param {string} endpoint API endpoint to fetch from
 * @param {RequestInit} options Fetch options
 * @returns {Promise<T>} API response
 */
export const apiFetch = async <T>(endpoint: string, options: RequestInit = {}): Promise<T> => {
    const isGet = !options.method || options.method.toUpperCase() === 'GET';
    const logContext = { endpoint, method: options.method || 'GET' };
    log('info', 'API fetch started.', logContext);
    
    try {
        const headers = {
            'Content-Type': 'application/json',
            ...options.headers,
        };

        // Add Netlify Identity token if available
        if (window.netlifyIdentity?.currentUser) {
            const token = await window.netlifyIdentity.currentUser()?.jwt();
            if (token) {
                Object.assign(headers, { 'Authorization': `Bearer ${token}` });
            }
        }

        const response = await fetch(`/.netlify/functions/${endpoint}`, {
            ...options,
            cache: isGet ? 'no-store' : undefined,
            headers,
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'An unexpected error occurred.' }));
            const error = errorData.error || `Server responded with status: ${response.status}`;
            log('error', 'API fetch failed.', { ...logContext, status: response.status, error });
            throw new Error(error);
        }

        if (response.status === 204 || response.headers.get('content-length') === '0') {
            log('info', 'API fetch successful with no content.', { ...logContext, status: response.status });
            return null as T;
        }

        const data = await response.json();
        log('info', 'API fetch successful.', { ...logContext, status: response.status });
        return data;

    } catch (error) {
        if (!(error instanceof Error && error.message.includes('Server responded with status'))) {
           log('error', 'API fetch encountered a network or parsing error.', { 
               ...logContext, 
               error: error instanceof Error ? error.message : String(error) 
           });
        }
        throw error;
    }
};

// Export cache manager for testing
export const __internals = {
    CacheManager,
    fetchWithCache,
    generateAnalysisKey
};

// BMS System Management API
export const getRegisteredSystems = async (page = 1, limit = 25): Promise<PaginatedResponse<BmsSystem>> => {
    log('info', 'Fetching paginated registered BMS systems.', { page, limit });
    const response = await fetchWithCache<any>(`systems?page=${page}&limit=${limit}`, CACHE_CONFIG.MEDIUM);
    
    if (Array.isArray(response)) {
        return {
            items: [...response],
            totalItems: response.length
        };
    }
    
    if (response && typeof response === 'object') {
        const totalItems = typeof response.total === 'number' ? response.total :
                        typeof response.totalItems === 'number' ? response.totalItems :
                        undefined;
        
        if (Array.isArray(response.items)) {
            return {
                items: response.items,
                totalItems: totalItems ?? response.items.length
            };
        }
        
        if (totalItems !== undefined) {
            return {
                items: [],
                totalItems
            };
        }
        
        if (Object.keys(response).length > 0) {
            return {
                items: [response],
                totalItems: 1
            };
        }
    }
    
    return { items: [], totalItems: 0 };
};

[...REST OF THE FILE CONTENT...]