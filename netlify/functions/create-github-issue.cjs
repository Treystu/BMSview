// @ts-nocheck
/**
 * Create GitHub Issue Endpoint
 * Auto-generates GitHub issues from AI feedback
 */

const { createLogger, createLoggerFromEvent, createTimer } = require('./utils/logger.cjs');
const { getCollection } = require('./utils/mongodb.cjs');
const { getCorsHeaders } = require('./utils/cors.cjs');
const { retryAsync } = require('./utils/retry.cjs');

/**
 * Format feedback as GitHub issue
 */
function formatGitHubIssue(feedback) {
  const priorityEmoji = {
    critical: 'ðŸ”´',
    high: 'ðŸŸ ',
    medium: 'ðŸŸ¡',
    low: 'âšª'
  };
  
  const categoryEmoji = {
    weather_api: 'ðŸŒ¤ï¸',
    data_structure: 'ðŸ—„ï¸',
    ui_ux: 'ðŸŽ¨',
    performance: 'âš¡',
    integration: 'ðŸ”Œ',
    analytics: 'ðŸ“Š'
  };
  
  const title = `${priorityEmoji[feedback.priority]} ${categoryEmoji[feedback.category]} ${feedback.suggestion.title}`;
  
  const body = `
## AI-Generated Feedback

**Type:** ${feedback.feedbackType.replace('_', ' ')}  
**Category:** ${feedback.category.replace('_', ' ')}  
**Priority:** ${feedback.priority.toUpperCase()}  
**Generated by:** ${feedback.geminiModel}  
**System ID:** ${feedback.systemId}

---

### Description

${feedback.suggestion.description}

### Rationale

${feedback.suggestion.rationale}

### Expected Benefit

${feedback.suggestion.expectedBenefit}

### Implementation Details

${feedback.suggestion.implementation}

**Estimated Effort:** ${feedback.suggestion.estimatedEffort}

${feedback.suggestion.affectedComponents && feedback.suggestion.affectedComponents.length > 0 ? `
### Affected Components

${feedback.suggestion.affectedComponents.map(comp => `- ${comp}`).join('\n')}
` : ''}

${feedback.suggestion.codeSnippets && feedback.suggestion.codeSnippets.length > 0 ? `
### Suggested Code

\`\`\`javascript
${feedback.suggestion.codeSnippets.join('\n\n')}
\`\`\`
` : ''}

---

*This issue was automatically generated from AI feedback on ${new Date(feedback.timestamp).toLocaleDateString()}*  
*Feedback ID: ${feedback.id}*
`;

  const labels = [
    'ai-generated',
    `priority-${feedback.priority}`,
    `category-${feedback.category}`,
    feedback.feedbackType
  ];

  return { title, body, labels };
}

/**
 * Create GitHub issue using the GitHub API
 * @param {object} issueData - The issue data with title, body, and labels
 * @param {object} log - Logger instance for structured logging
 */
async function createGitHubIssueAPI(issueData, log) {
  // Validate required fields
  if (!issueData || typeof issueData !== 'object') {
    throw new Error('issueData must be an object');
  }
  
  if (!issueData.title || typeof issueData.title !== 'string') {
    throw new Error('issueData.title is required and must be a string');
  }
  
  if (!issueData.body || typeof issueData.body !== 'string') {
    throw new Error('issueData.body is required and must be a string');
  }
  
  // Get repository info from environment or use default
  const repoOwner = process.env.GITHUB_REPO_OWNER || 'Treystu';
  const repoName = process.env.GITHUB_REPO_NAME || 'BMSview';
  const githubToken = process.env.GITHUB_TOKEN;
  
  if (!githubToken) {
    throw new Error('GITHUB_TOKEN environment variable is not configured. Please set it in Netlify environment variables.');
  }
  
  log.info('Calling GitHub API to create issue', {
    repoOwner,
    repoName,
    title: issueData.title,
    labelsCount: issueData.labels?.length || 0
  });
  
  // Wrap the fetch call with retry logic for transient failures
  const response = await retryAsync(async () => {
    const res = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/issues`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Accept': 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'User-Agent': 'BMSview-AI-Feedback',
        'X-GitHub-Api-Version': '2022-11-28'
      },
      body: JSON.stringify(issueData)
    });
    
    // Check for retryable errors (rate limit, server errors)
    if (!res.ok && (res.status === 429 || res.status >= 500)) {
      const error = new Error(`GitHub API error: ${res.status}`);
      error.status = res.status;
      throw error;
    }
    
    return res;
  }, {
    retries: 3,
    baseDelayMs: 500,
    jitterMs: 200,
    shouldRetry: (e) => {
      // Retry on network errors (TypeError from fetch)
      if (e instanceof TypeError) return true;
      // Retry on rate limit or server errors
      if (e.status === 429 || e.status >= 500) return true;
      return false;
    },
    log
  });
  
  if (!response.ok) {
    const errorJson = await response.json().catch(() => ({}));
    
    const errorDetails = {
      status: response.status,
      message: errorJson.message || response.statusText,
      documentation_url: errorJson.documentation_url,
      errors: errorJson.errors
    };
    
    let errorMessage = `GitHub API error (${response.status}): ${errorDetails.message}`;
    if (errorDetails.documentation_url) {
      errorMessage += `\nSee: ${errorDetails.documentation_url}`;
    }
    
    const error = new Error(errorMessage);
    error.status = response.status;
    error.details = errorDetails;
    throw error;
  }
  
  const result = await response.json();
  
  log.info('GitHub issue created successfully', {
    issueNumber: result.number,
    issueUrl: result.html_url
  });
  
  return {
    number: result.number,
    url: result.url,
    html_url: result.html_url,
    state: result.state,
    created_at: result.created_at
  };
}

/**
 * Main handler
 */
exports.handler = async (event, context) => {
  const log = createLoggerFromEvent('create-github-issue', event, context);
  const timer = createTimer(log, 'create-github-issue-handler');
  const headers = getCorsHeaders(event);
  
  log.entry({ method: event.httpMethod, path: event.path });
  
  // Handle preflight
  if (event.httpMethod === 'OPTIONS') {
    log.debug('OPTIONS preflight request');
    timer.end();
    log.exit(200);
    return { statusCode: 200, headers };
  }
  
  try {
    if (event.httpMethod !== 'POST') {
      log.warn('Method not allowed', { method: event.httpMethod });
      timer.end();
      log.exit(405);
      return {
        statusCode: 405,
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Method not allowed' })
      };
    }
    
    const body = JSON.parse(event.body);
    const { feedbackId, feedback } = body;
    
    if (!feedbackId && !feedback) {
      return {
        statusCode: 400,
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Either feedbackId or feedback is required' })
      };
    }
    
    // Get feedback from database if only ID provided
    let feedbackData = feedback;
    if (feedbackId && !feedback) {
      const feedbackCollection = await getCollection('ai_feedback');
      feedbackData = await feedbackCollection.findOne({ id: feedbackId });
      
      if (!feedbackData) {
        return {
          statusCode: 404,
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({ error: 'Feedback not found' })
        };
      }
      
      // Check if already has GitHub issue
      if (feedbackData.githubIssue) {
        return {
          statusCode: 409,
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({
            error: 'GitHub issue already exists for this feedback',
            githubIssue: feedbackData.githubIssue
          })
        };
      }
    }
    
    log.info('Creating GitHub issue for AI feedback', {
      feedbackId: feedbackData.id,
      priority: feedbackData.priority
    });
    
    // Format issue
    const issueData = formatGitHubIssue(feedbackData);
    
    // Create GitHub issue
    const githubIssue = await createGitHubIssueAPI(issueData, log);
    
    // Update feedback with GitHub issue info
    if (feedbackId) {
      const feedbackCollection = await getCollection('ai_feedback');
      await feedbackCollection.updateOne(
        { id: feedbackId },
        {
          $set: {
            githubIssue: {
              number: githubIssue.number,
              url: githubIssue.html_url,
              status: githubIssue.state
            },
            updatedAt: new Date()
          }
        }
      );
    }
    
    log.info('GitHub issue created successfully', {
      feedbackId: feedbackData.id,
      issueNumber: githubIssue.number
    });
    
    timer.end({ success: true });
    log.exit(200, { issueNumber: githubIssue.number });
    
    return {
      statusCode: 200,
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        success: true,
        issueNumber: githubIssue.number,
        issueUrl: githubIssue.html_url,
        feedbackId: feedbackData.id
      })
    };
  } catch (error) {
    log.error('Create GitHub issue error', { error: error.message, stack: error.stack });
    timer.end({ success: false, error: error.message });
    log.exit(500);
    return {
      statusCode: 500,
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: 'Failed to create GitHub issue',
        message: error.message
      })
    };
  }
};

// Export for testing
module.exports.formatGitHubIssue = formatGitHubIssue;
module.exports.createGitHubIssueAPI = createGitHubIssueAPI;
