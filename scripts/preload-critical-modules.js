#!/usr/bin/env node
/**
 * Script to preload critical modules for better performance
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

const CRITICAL_MODULES = [
  // Core React components
  'src/components/FileUpload/FileUpload.tsx',
  'src/components/AnalysisResults/AnalysisResults.tsx',
  'src/components/LazyComponents.tsx',

  // Essential utilities
  'src/utils/bundleOptimization.ts',
  'src/utils/performance.ts',
  'src/utils/errorBoundary.tsx',

  // State management
  'src/state/enhancedAppState.tsx',

  // Hooks
  'src/hooks/usePerformanceOptimization.ts',

  // Services (lightweight ones)
  'src/services/clientService.ts',
];

const PRELOAD_TEMPLATE = `// Auto-generated preload script
// This file is automatically generated by scripts/preload-critical-modules.js

export const preloadCriticalModules = async () => {
  const modulePromises = [
{{IMPORT_STATEMENTS}}
  ];

  try {
    await Promise.allSettled(modulePromises);
    console.debug('[Preloader] Critical modules preloaded');
  } catch (error) {
    console.warn('[Preloader] Some modules failed to preload:', error);
  }
};

export const CRITICAL_MODULE_NAMES = [
{{MODULE_NAMES}}
];

// Automatically start preloading if this module is imported
if (typeof window !== 'undefined' && window.requestIdleCallback) {
  window.requestIdleCallback(() => {
    preloadCriticalModules();
  }, { timeout: 3000 });
} else if (typeof window !== 'undefined') {
  setTimeout(preloadCriticalModules, 1000);
}

export default preloadCriticalModules;`;

async function generatePreloadScript() {
  console.log('üöÄ Generating critical module preloader...');

  const importStatements = [];
  const moduleNames = [];

  for (const modulePath of CRITICAL_MODULES) {
    const fullPath = path.resolve(rootDir, modulePath);

    try {
      await fs.access(fullPath);

      // Convert to relative import path
      const importPath = modulePath.replace(/^src\//, '../').replace(/\.tsx?$/, '');
      importStatements.push(`    import('${importPath}').catch(console.warn),`);

      const moduleName = path.basename(modulePath, path.extname(modulePath));
      moduleNames.push(`  '${moduleName}',`);

      console.log(`‚úÖ Added ${modulePath}`);
    } catch (error) {
      console.warn(`‚ö†Ô∏è  Module not found: ${modulePath}`);
    }
  }

  const preloadScript = PRELOAD_TEMPLATE
    .replace('{{IMPORT_STATEMENTS}}', importStatements.join('\n'))
    .replace('{{MODULE_NAMES}}', moduleNames.join('\n'));

  const outputPath = path.resolve(rootDir, 'src/utils/preloader.ts');
  await fs.writeFile(outputPath, preloadScript);

  console.log(`üìù Generated preloader at: ${outputPath}`);
  console.log(`üìä Configured ${importStatements.length} critical modules`);
}

async function analyzeModuleDependencies() {
  console.log('üìà Analyzing module dependencies...');

  const dependencyMap = new Map();
  const moduleStats = {
    totalModules: 0,
    totalSize: 0,
    criticalModules: CRITICAL_MODULES.length,
  };

  for (const modulePath of CRITICAL_MODULES) {
    const fullPath = path.resolve(rootDir, modulePath);

    try {
      const stats = await fs.stat(fullPath);
      const content = await fs.readFile(fullPath, 'utf-8');

      // Extract import statements
      const imports = content.match(/^import.*from\s+['"]([^'"]+)['"]/gm) || [];
      const dependencies = imports.map(imp => {
        const match = imp.match(/from\s+['"]([^'"]+)['"]/);
        return match ? match[1] : null;
      }).filter(Boolean);

      dependencyMap.set(modulePath, {
        size: stats.size,
        dependencies,
        isRelative: dependencies.filter(dep => dep.startsWith('.') || dep.startsWith('@/')).length,
        isExternal: dependencies.filter(dep => !dep.startsWith('.') && !dep.startsWith('@/')).length,
      });

      moduleStats.totalSize += stats.size;
      moduleStats.totalModules++;
    } catch (error) {
      console.warn(`Failed to analyze ${modulePath}:`, error.message);
    }
  }

  console.log('\nüìä Module Analysis Results:');
  console.log(`Total critical modules: ${moduleStats.criticalModules}`);
  console.log(`Total size: ${(moduleStats.totalSize / 1024).toFixed(2)} KB`);
  console.log(`Average size: ${(moduleStats.totalSize / moduleStats.totalModules / 1024).toFixed(2)} KB`);

  // Find modules with most dependencies
  const sortedByDeps = Array.from(dependencyMap.entries())
    .sort(([, a], [, b]) => b.dependencies.length - a.dependencies.length)
    .slice(0, 5);

  console.log('\nüîó Modules with most dependencies:');
  sortedByDeps.forEach(([module, info]) => {
    console.log(`  ${path.basename(module)}: ${info.dependencies.length} deps (${info.isExternal} external)`);
  });

  // Find largest modules
  const sortedBySize = Array.from(dependencyMap.entries())
    .sort(([, a], [, b]) => b.size - a.size)
    .slice(0, 5);

  console.log('\nüì¶ Largest modules:');
  sortedBySize.forEach(([module, info]) => {
    console.log(`  ${path.basename(module)}: ${(info.size / 1024).toFixed(2)} KB`);
  });

  return dependencyMap;
}

async function generatePreloadReport() {
  console.log('\nüìã Generating preload optimization report...');

  const reportTemplate = `# Bundle Optimization Report

Generated on: ${new Date().toISOString()}

## Critical Modules Configuration

The following modules are configured for preloading:

${CRITICAL_MODULES.map(mod => `- \`${mod}\``).join('\n')}

## Optimization Strategies

### 1. Module Preloading
- Critical modules are preloaded using \`requestIdleCallback\`
- Fallback to \`setTimeout\` for browsers without idle callback support
- Error handling prevents failures from breaking the app

### 2. Code Splitting
- Configured in \`vite.config.ts\` with manual chunks
- Vendor libraries separated by type and size
- Component-based splitting for lazy loading

### 3. Bundle Analysis
- Run \`npm run analyze:bundle\` to generate visual bundle analysis
- Monitor chunk sizes and dependencies
- Identify optimization opportunities

### 4. Performance Monitoring
- Built-in performance tracking in development
- Bundle size warnings for large chunks
- Component render time monitoring

## Usage

### Automatic Preloading
```typescript
// Modules are automatically preloaded when imported
import preloadCriticalModules from './utils/preloader';
```

### Manual Preloading
```typescript
import { preloadCriticalModules } from './utils/preloader';

// Preload on user interaction
button.addEventListener('mouseenter', () => {
  preloadCriticalModules();
});
```

### Bundle Analysis
\`\`\`bash
# Generate bundle visualization
npm run build:analyze

# Performance audit
npm run performance:audit
\`\`\`

## Recommendations

1. **Monitor bundle size regularly** - Keep total bundle under 1MB
2. **Use lazy loading** - Load non-critical components on demand
3. **Optimize images** - Compress and use modern formats
4. **Enable compression** - Use gzip/brotli compression
5. **Cache optimization** - Leverage browser and CDN caching

## Next Steps

1. Implement Progressive Web App (PWA) features
2. Add service worker for offline caching
3. Optimize database queries and API calls
4. Implement virtual scrolling for large lists
5. Add resource hints and preload directives
`;

  const reportPath = path.resolve(rootDir, 'docs/bundle-optimization.md');

  try {
    await fs.mkdir(path.dirname(reportPath), { recursive: true });
    await fs.writeFile(reportPath, reportTemplate);
    console.log(`üìÑ Report generated: ${reportPath}`);
  } catch (error) {
    console.warn('Failed to generate report:', error.message);
  }
}

async function main() {
  try {
    console.log('üéØ Bundle Optimization Setup');
    console.log('=' .repeat(40));

    await generatePreloadScript();
    await analyzeModuleDependencies();
    await generatePreloadReport();

    console.log('\n‚úÖ Bundle optimization setup complete!');
    console.log('\nNext steps:');
    console.log('1. Run `npm run build:analyze` to see bundle composition');
    console.log('2. Import the preloader in your main app file');
    console.log('3. Monitor performance with the built-in tools');
    console.log('4. Review the optimization report in docs/');

  } catch (error) {
    console.error('‚ùå Failed to setup bundle optimization:', error);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}