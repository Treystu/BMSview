Scope anchors

Cache/indexedDB: localCache.ts
Sync engine: syncManager.ts
Client dual-write/temp records: clientService.ts
Error to fix: AsyncWorkloadsClient missing baseUrl; Netlify?.context?.url not accessible (likely in async workload functions such as generate-insights-async-trigger/background).
Plan (actions in order)

Unified time utility and validation
Extract shared time helper: nowUtc() and assertUtc() reusing getCurrentUTCTimestamp() and UTC_TIMESTAMP_REGEX.
Replace direct new Date().toISOString() usages in:
Temp cache writes: saveAnalysisResult() temp record, temp system IDs, other temp writes.
Sync pulls before cache writes: pullIncremental().
Add drift warning: compare serverTime from sync-metadata to client now; log if |drift| > threshold.
ID and temp record hygiene
Standardize temp IDs: temp-{collection}-{timestamp}-{rand} for systems/history/analytics/weather.
On server success, replace temp IDs and mark synced via markAsSynced() to avoid orphan temps.
Fully indexed cache (Dexie schema upgrade)
Add compound indexes aligned to queries:
systems: ['id'], ['_syncStatus'], ['updatedAt']
history: ['id'], ['systemId'], ['systemId','timestamp'], ['_syncStatus'], ['timestamp']
analytics: ['id'], ['systemId','metric','timestamp'], ['_syncStatus']
weather: ['id'], ['location'], ['_syncStatus'], ['updatedAt']
metadata: ['id'], ['collection'], ['collection','lastModified']
Update staleness helpers to use indexed queries instead of full scans: getStaleItems() and purge paths.
Server-wins and validation on ingest
In cache upserts, if payload has updatedAt, validate; else set to nowUtc(). Reject/flag invalid timestamps rather than silently accepting.
In reconcileData(), flag conflicts on missing/invalid timestamps, not just time deltas.
Sync coverage and pending flows
Extend periodic sync to handle analytics/weather pending items (push + markAsSynced) similar to systems/history.
Ensure delete support for all cache collections on pull (history/systems covered; add analytics/weather delete paths if missing).
Keep resetPeriodicTimer calls after dual-writes (already present) and optionally add per-collection “kick” sync for user actions.
Staleness/retention policy
Centralize thresholds (currently default 1h in getStaleItems()); allow per-collection overrides.
Periodic purge using indexed updatedAt; update metadataCache.update() after purge.
Logging/metrics
Standard log envelope: {ts, collection, action, source, syncStatus}.
Track temp-ID replacement success rate; approximate cache index effectiveness via code-path counters.
Tests to add
Timestamp validation and drift alert.
Reconcile conflict surfacing on invalid/missing timestamps.
Indexed staleness queries (ensure no full scans).
Temp ID replacement and pending->synced transitions.
AsyncWorkloadsClient baseUrl fix (new added item)

Identify where AsyncWorkloadsClient is instantiated (likely in Netlify async workload functions: generate-insights-async-trigger/background).
Provide explicit baseUrl derived from env/config (e.g., process.env.URL or a configured PUBLIC_BASE_URL), not Netlify?.context?.url.
Validate payload timestamp handling in async paths to align with unified time utility; ensure responses and stored records use ISO UTC.
Next steps suggested

Approve implementation of:
Shared time utility + replacements.
Dexie schema/index upgrade + staleness refactor.
Pending sync support for analytics/weather + delete handling.
AsyncWorkloadsClient baseUrl configuration and fallback logic.
Targeted tests for the above.